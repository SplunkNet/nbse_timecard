<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_nyk_nbse_time_ca.NBSETimeCardUtil</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>NBSETimeCardUtil</name>
        <script>var NBSETimeCardUtil = Class.create();&#13;
NBSETimeCardUtil.prototype = {&#13;
    initialize: function() {&#13;
			"use strict";&#13;
		&#13;
		this.TABLE_TIMESHEET          = 'x_nyk_nbse_time_ca_nbse_timesheet';&#13;
		this.TABLE_ASSIGNMENT         = 'x_nyk_nbse_time_ca_nbse_assignment';&#13;
//		this.TABLE_NON_WORK_TIME      = 'x_nyk_nbse_time_ca_nbse_non_work_time';&#13;
		this.TABLE_WEEK               = 'x_nyk_nbse_time_ca_week';&#13;
		//this.TABLE_LEAVE_TIME         = 'x_nykl3_tenroxnbsa_leave_time';&#13;
		//this.TABLE_PAYROLL_SCHEDULE   = 'x_nykl3_tenroxnbsa_payroll_schedule';&#13;
		//this.TABLE_ADP_REPORT         = 'x_nykl3_tenroxnbsa_adp_report';&#13;
	//	this.TABLE_LEAVE_TYPE         = 'x_nykl3_tenroxnbsa_leave_type';&#13;
		this.TABLE_HOLIDAY            = 'x_nyk_nbse_time_ca_nbse_holidays';&#13;
		//this.TABLE_TIMESHEET_TEMPLATE = 'x_nykl3_tenroxnbsa_timesheet_template';&#13;
		this.TABLE_USER_PROFILE       = 'x_nyk_nbse_time_ca_nbse_user_profile';&#13;
		this.TABLE_BILL_RATE          = 'x_nyk_nbse_time_ca_nbse_bill_rate';&#13;
		this.TABLE_PROJECT_WORK_TYPE  = 'x_nyk_nbse_time_ca_nbse_project_work_type';&#13;
		this.TABLE_PROJECT_M2M_TYPE   = 'x_nyk_nbse_time_ca_m2m_nbse_projec_nbse_project';&#13;
		&#13;
		this.ROLE_USER                = 'x_nyk_nbse_time_ca.nbse_timesheet_user';&#13;
		//this.CO_CODE                  = '69L';&#13;
		//this.REG_HOURS                = 86.67;&#13;
		//this.MAX_PTO_HRS              = 3.5; //PTO stands for Personal Time Out of Office&#13;
		//this.MAX_MAL_HRS              = 8; //MAL stands for Manager Approved Leave, Added by Gulzar on 12/17/2018&#13;
		this.MAX_LEAVE_HRS            = 7;&#13;
		//this.MAX_TRAVEL_HRS           = 24;&#13;
		this.INCREMENT_EXEMPT         = 4;&#13;
		//this.INCREMENT_NON_EXEMPT     = 0.50;&#13;
		//this.INCREMENT_PTO            = 0.25;&#13;
		//this.INCREMENT_MAL            = 0.50;  // Added by Gulzar Manuja on 12/17/2018&#13;
	//	this.OT_ENM_HOLIDAY_THRESHOLD = 5; //ENM stands for Exempt Non Manager&#13;
	//	this.OT_ENM_WEEKDAY_THRESHOLD = 13;&#13;
	//	this.OT_ENM                   = 8;&#13;
		&#13;
		this.au        = new global.ArrayUtil();&#13;
		this.snUtils   = new global.NBSA_SNUtils();&#13;
		&#13;
		this.daysInWeek    = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];&#13;
		&#13;
	},&#13;
	&#13;
	/*&#13;
	 * This function will scan the Holiday Table and return the days for which it holiday&#13;
	 * For example, if 11th and 12th December 2020 is holiday, then it will return 'mon, tue'&#13;
	 * &#13;
	 * Input: @start: week start date&#13;
	 * Output: comma separated string of days e.g. 'tue, wed, fri'&#13;
	 */&#13;
	&#13;
	getHolidays: function(start) {&#13;
		"use strict";&#13;
		&#13;
		var holidays = '';&#13;
		var gt = new GlideDateTime(start);&#13;
		gt.addDaysUTC(-1);&#13;
		['mon', 'tue', 'wed', 'thu', 'fri'].forEach(function(w) {&#13;
			gt.addDaysUTC(1);&#13;
			if (this.snUtils.getA(this.TABLE_HOLIDAY, ['date='+gt.getDate()], ['name']).length == 1) holidays += w+',';&#13;
		}, this);&#13;
		if (holidays.endsWith(',')) {&#13;
			holidays = holidays.substring(0, holidays.length-1);&#13;
		}&#13;
		return holidays;&#13;
	},&#13;
	&#13;
	/*&#13;
	 * This Function will calculate total hours for each day for the timesheet (Assignments + Non-Work Time)&#13;
	 */&#13;
	&#13;
	getTotalHrsForEachDay: function(timesheet) {&#13;
		"use strict";&#13;
		&#13;
		var days = [['mon', 0], ['tue', 0], ['wed', 0], ['thu', 0], ['fri', 0], ['sat', 0], ['sun', 0], ['reg', 0], ['nwt', 0]];&#13;
		&#13;
		var daysAssignment = this.getTotalHrsForEachDayAssignments(timesheet);&#13;
		var daysNWT = this.getTotalHrsForEachDayNWT(timesheet);&#13;
		&#13;
		for (var d in days) {&#13;
			days[d][1] = daysAssignment[d][1] + daysNWT[d][1];&#13;
		}&#13;
		&#13;
		gs.debug('getTotalHrsForEachDay: for timesheet: '+timesheet.timesheet+', days: '+days);&#13;
		return days;&#13;
	},&#13;
	&#13;
	/*&#13;
	 * This Function will calculate total hours for each day for the timesheet Assignments&#13;
	 */&#13;
	&#13;
	getTotalHrsForEachDayAssignments: function(timesheet) {&#13;
		"use strict";&#13;
		&#13;
		var days = [['mon', 0], ['tue', 0], ['wed', 0], ['thu', 0], ['fri', 0], ['sat', 0], ['sun', 0]];&#13;
		&#13;
		// Get total time for each day the assignments for the timesheet&#13;
		this.snUtils.getA(this.TABLE_ASSIGNMENT, ['timesheet='+timesheet.sys_id], this.daysInWeek).forEach(function(ts) {&#13;
			for (var x in ts) {&#13;
				if (ts[x]) {&#13;
					days[x][1] += parseFloat(ts[x]);&#13;
				}&#13;
			}&#13;
		}, this);&#13;
		&#13;
		&#13;
		/* Commented by Gulzar Manuja on 02/25/2020&#13;
		&#13;
		// Lunch break hours will also be counted in the assignment (regular) hours&#13;
		var lunchBreak = this.snUtils.getA(this.TABLE_NON_WORK_TIME, ['timesheet='+timesheet.sys_id, 'nwt.name=Lunch Break'], this.daysInWeek);&#13;
		gs.debug('getTotalHrsForEachDayAssignments: for timesheet: '+timesheet.timesheet+', lunchBreak: '+lunchBreak+', lunchBreak.length: '+lunchBreak.length);&#13;
		&#13;
		if (lunchBreak.length == 1) {&#13;
			for (var x=0; x&lt;=6; x++) {&#13;
				if (lunchBreak[0][x]) {&#13;
					days[x][1] += parseFloat(lunchBreak[0][x]);&#13;
				}&#13;
			}&#13;
		}&#13;
		*/&#13;
		gs.debug('getTotalHrsForEachDayAssignments: for timesheet: '+timesheet.timesheet+', days: '+days);&#13;
		return days;&#13;
	},&#13;
	&#13;
	/*&#13;
	 * This Function will calculate total hours for each day for the timesheet Non-Work Time&#13;
	 */&#13;
	&#13;
	&#13;
	/* Commented by Gulzar Manuja on 02/25/2020&#13;
&#13;
	getTotalHrsForEachDayNWT: function(timesheet) {&#13;
		"use strict";&#13;
		&#13;
		var days = [['mon', 0], ['tue', 0], ['wed', 0], ['thu', 0], ['fri', 0], ['sat', 0], ['sun', 0]];&#13;
		&#13;
		// Get all the non work times except lunch break, which is considered in the Regular Time&#13;
		this.snUtils.getA(this.TABLE_NON_WORK_TIME, ['timesheet='+timesheet.sys_id, 'nwt.name!=Lunch Break'], this.daysInWeek).forEach(function(ts) {&#13;
			for (var x in ts) {&#13;
				if (ts[x]) {&#13;
					days[x][1] += parseFloat(ts[x]);&#13;
				}&#13;
			}&#13;
		}, this);&#13;
		&#13;
		gs.debug('getTotalHrsForEachDayNWT: for timesheet: '+timesheet.timesheet+', days: '+days);&#13;
		return days;&#13;
	},&#13;
	&#13;
	 &#13;
	&#13;
	updateOTSH: function(tsSysID, category, total, ot, sh, reg, holidays) {&#13;
		"use strict";&#13;
		var overTime, straightHour;&#13;
		if (category == 'Non-Exempt') {&#13;
			overTime = this.calOTNonExempt(reg);&#13;
			straightHour = this.calSH(total, overTime, category);&#13;
		}&#13;
		&#13;
		Comments added by Gulzar Manuja end here */&#13;
		// Commented on 06/14/2019 as requested by Nancy&#13;
		&#13;
		/*else if (category == 'Exempt Non-Manager')&#13;
			overTime = this.calOTExemptNM(tsSysID, holidays); */&#13;
	&#13;
	/* Commented by Gulzar Manuja on 02/25/2020&#13;
		else&#13;
			return;&#13;
		var ts = {};&#13;
		//if (overTime &amp;&amp; overTime != ot) &#13;
		ts.ot = overTime;&#13;
		//if (straightHour &amp;&amp; straightHour != sh)&#13;
		ts.sh = straightHour;&#13;
		//if (ts.ot || ts.sh)&#13;
		this.snUtils.grS(this.TABLE_TIMESHEET, tsSysID, ts);&#13;
	},&#13;
&#13;
		&#13;
		&#13;
	&#13;
	//Calculates Straigh Hours for a Non-Exempt Employee&#13;
	calSH: function(total, ot, category) {&#13;
		if (category != 'Non-Exempt' || total == undefined || ot == undefined)&#13;
			return 0;&#13;
		return parseFloat(total) - 40 - parseFloat(ot) &gt; 0 ? parseFloat(total) - 40 - parseFloat(ot) : 0;&#13;
	},&#13;
	&#13;
	&#13;
	//Calculates Over Time for a Non-Exempt Employee&#13;
	calOTNonExempt: function(reg) {&#13;
		"use strict";&#13;
		&#13;
		return reg&gt;40? reg-40:0;&#13;
	},&#13;
	&#13;
	Commented till here by Gulzar Manuja on 02/25/2020 */&#13;
	&#13;
	/*&#13;
	 * This function will check if this is a duplicate non work time&#13;
	 * If it's duplicate, it won't return anything&#13;
	 */&#13;
	&#13;
	/* Commented by Gulzar Manuja on 02/25/2020&#13;
	&#13;
	isDuplicateNonWorkTime: function(nonWorkTime) {&#13;
		"use strict";&#13;
		&#13;
		if (this.snUtils.getA(this.TABLE_NON_WORK_TIME,  ['timesheet='+nonWorkTime.timesheet.sys_id, 'nwt='+nonWorkTime.nwt, 'sys_id!='+nonWorkTime.sys_id], ['sys_id']).length &gt;0) {&#13;
			return 'Duplicate Non-Work Time: '+nonWorkTime.nwt.name;&#13;
		}&#13;
	},&#13;
	&#13;
		Commented till here by Gulzar Manuja on 02/25/2020 */&#13;
		&#13;
		&#13;
	/*&#13;
 	 * This function will validate if an array of hours is valid&#13;
 	 * it's valid if all the values in array are less than 'max' and in increment of increment&#13;
 	 */&#13;
	&#13;
	/* Commented by Lavlesh Garg on 02/26/2020 - not being used anywhere&#13;
	validateHours: function(hoursForEachWeekDay, max, increment, nwtName) {&#13;
		"use strict";&#13;
		&#13;
		var h;&#13;
		for(var hr in hoursForEachWeekDay) {&#13;
			h = hoursForEachWeekDay[hr];&#13;
			if (h) {&#13;
				if (parseFloat(h) &gt; max)&#13;
					return 'Invalid filled hours for '+nwtName+', max allowed is '+max+', filled: '+h;&#13;
				else if (parseFloat(h)%increment !=0)&#13;
					return 'Invalid fileld hours for '+nwtName+', should be in increments of '+increment+', filled: '+h;&#13;
			}&#13;
		}&#13;
	},&#13;
	*/&#13;
	&#13;
	/*&#13;
 	 * This function will validate if an array of lunch hours is valid&#13;
 	 * it's valid if all the values in array are either 0 or 1&#13;
 	 */&#13;
	&#13;
	/* Commented by Gulzar Manuja on 02/25/2020&#13;
	&#13;
	validateLunchHours: function(hoursForEachWeekDay) {&#13;
		"use strict";&#13;
		&#13;
		var h;&#13;
		for(var hr in hoursForEachWeekDay) {&#13;
			h = hoursForEachWeekDay[hr];&#13;
			if (h &amp;&amp; !(h==0 || h==1)) {&#13;
				return 'Invalid filled hours for Lunch Break, allowed is 0 or 1, filled: '+h;&#13;
			}&#13;
		}&#13;
	},&#13;
	&#13;
	Commented till here by Gulzar Manuja on 02/25/2020 */&#13;
	&#13;
	/* &#13;
	 * This function will validate if the hours filled in Non-Work times are valid or not&#13;
 	 * 1. Check if employee have enough vacations available to fill-in&#13;
 	 * 2. Exempt Employees can only fill in 0, 4 or 8 hours&#13;
 	 *    Non Exempt Employees can fill in increments of 0.25 hours&#13;
 	 * &#13;
	 * Input:&#13;
	 *     @hoursForEachWeekDay: This is an array of hours for each day e.g.: [4, 6, 2, 6, 8, 0, 0]&#13;
	 *     @nwt: Non Work Time Record&#13;
	 *     @employeeCategory: Employee Category&#13;
	 *&#13;
	 * Return:&#13;
	 *     Returns nothing if work hours validated&#13;
	 *     Returns error if works hours doesn't validate&#13;
	 */&#13;
	&#13;
	/* Commented by Gulzar Manuja on 02/25/2020&#13;
	&#13;
	validateNonWorkHours: function (hoursForEachWeekDay, nwt, employeeCategory) {&#13;
		"use strict";&#13;
		&#13;
		var totalHours       = 0;&#13;
		var nwtName          = nwt.name;&#13;
		&#13;
		// Get Total Hours for the timesheet&#13;
		hoursForEachWeekDay.forEach(function(x) {&#13;
			totalHours += parseFloat(x);&#13;
		});&#13;
		&#13;
		gs.debug('Hours: '+hoursForEachWeekDay+', non work type: '+nwtName);&#13;
		&#13;
		if (totalHours == 0)&#13;
			return;&#13;
		&#13;
		if (nwtName == 'Lunch Break')&#13;
			return this.validateLunchHours(hoursForEachWeekDay);&#13;
		&#13;
		if (nwtName == 'Travel (Exempt)')&#13;
			return this.validateHours(hoursForEachWeekDay, this.MAX_TRAVEL_HRS, this.INCREMENT_PTO, nwtName);&#13;
&#13;
		if (nwtName == 'Personal Time Out of Office')&#13;
			return this.validateHours(hoursForEachWeekDay, this.MAX_PTO_HRS, this.INCREMENT_PTO, nwtName);&#13;
		&#13;
		// Added by Gulzar Manuja on 12/17/2018&#13;
		if (nwtName == 'Manager Approved Leave')&#13;
			return this.validateHours(hoursForEachWeekDay, this.MAX_MAL_HRS, this.INCREMENT_MAL, nwtName);&#13;
		// Changes end here&#13;
		&#13;
		if (employeeCategory.indexOf('Exempt') == 0)&#13;
			return this.validateHours(hoursForEachWeekDay, this.MAX_LEAVE_HRS, this.INCREMENT_EXEMPT, nwtName);&#13;
		&#13;
		if (employeeCategory == 'Non-Exempt')&#13;
			return this.validateHours(hoursForEachWeekDay, this.MAX_LEAVE_HRS, this.INCREMENT_NON_EXEMPT, nwtName);&#13;
	},&#13;
	&#13;
	Commented till here by Gulzar Manuja on 02/25/2020 */&#13;
	&#13;
	/*&#13;
	 * Author: Lavlesh Garg, 3/7/2018&#13;
	 * Purpose of this function is to ensure that total non work time for any day for timesheet doesn't exceeds 8 hours&#13;
	 * So, whenever a new non-work-type is entered / edited, this function will&#13;
	 * check whether by allowing insertion / updation of this record, non work time for any day for this timesheet&#13;
	 * would exceed 8 hours, if it does, insertion / updation of the record would be aborted.&#13;
	 */&#13;
	&#13;
	/* Commented by Gulzar Manuja on 02/25/2020&#13;
	&#13;
	validateMaxNWTHours : function(current, previous) {&#13;
		var nwh = 0, diff = 0, totalNWH = 0, max = 8;&#13;
		var weekDays = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];&#13;
		&#13;
		var travel;&#13;
		if (current.nwt.name == 'Travel (Exempt)')&#13;
			travel = [{&#13;
				'mon': current.getValue('mon'),&#13;
				'tue': current.getValue('tue'),&#13;
				'wed': current.getValue('wed'),&#13;
				'thu': current.getValue('thu'),&#13;
				'fri': current.getValue('fri'),&#13;
				'sat': current.getValue('sat'),&#13;
				'sun': current.getValue('sun'),&#13;
			}];&#13;
		else&#13;
			travel = this.snUtils.getO('x_nykl3_tenroxnbsa_non_work_time', ['timesheet='+current.timesheet.sys_id, 'nwt.name=Travel (Exempt)'], ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']);&#13;
		//This is the array of total non work time for each day of the timesheet.&#13;
		var timesheetNWH = [current.timesheet.mon_nwt, current.timesheet.tue_nwt, current.timesheet.wed_nwt, current.timesheet.thu_nwt, current.timesheet.fri_nwt];	&#13;
		var lunch;&#13;
		if (current.nwt.name == 'Lunch Break')&#13;
			lunch = [{'mon': current.getValue('mon'),&#13;
					  'tue': current.getValue('tue'),&#13;
					  'wed': current.getValue('wed'),&#13;
					  'thu': current.getValue('thu'),&#13;
					  'fri': current.getValue('fri'),&#13;
					  'sat': current.getValue('sat'),&#13;
					  'sun': current.getValue('sun'),&#13;
					  }];&#13;
		else&#13;
			lunch = this.snUtils.getO('x_nykl3_tenroxnbsa_non_work_time', ['timesheet='+current.timesheet.sys_id, 'nwt.name=Lunch Break'], ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']);&#13;
		&#13;
		for (var w in weekDays) {&#13;
		&#13;
			//nwh will store the already stored non work hours for this day (mon, tue ..) for the timesheet.&#13;
			nwh = timesheetNWH[w] ? timesheetNWH[w] : 0;&#13;
&#13;
			//Deduct existing lunch hours for the day as if it's 1 for monday for example, before deducting,&#13;
			//nwh would be 1 and 8 more hours of non work time is allowed becuase lunch hour would be made &#13;
			//0 if non work time is 4 or more hours			&#13;
			if (lunch[weekDays[w]])&#13;
				nwh = parseFloat(nwh) - parseFloat(lunch[weekDays[w]]);&#13;
&#13;
			//diff will store the change in non work hour for this day (mon, tue ..) for this non work type&#13;
			diff = current.getValue(weekDays[w]) ? parseFloat(current.getValue(weekDays[w])) : 0;&#13;
			if (previous.getValue(weekDays[w]))&#13;
				diff -= parseFloat(previous.getValue(weekDays[w]));&#13;
			&#13;
			//totalNWH will be the sum of nwf and diff&#13;
			totalNWH = parseFloat(nwh)+parseFloat(diff);&#13;
			&#13;
			if (travel &amp;&amp; travel!= undefined &amp;&amp; travel != '' &amp;&amp; travel[0][weekDays[w]] &amp;&amp; travel[0][weekDays[w]]&gt;0)&#13;
				max = 24;&#13;
			else&#13;
				max = 8;			&#13;
			//totalNWH should be &lt;= max. If it's more than max, show an error and about record submission&#13;
			if (totalNWH &gt; max) {&#13;
				return 'No More than '+max+' hours allowed in Total Non Work Times per timesheet day. For Non Work Type : '+current.nwt.name+', for '+weekDays[w]+', you entered '+current.getValue(weekDays[w])+' hours which makes total '+totalNWH+' hours for this day in timesheet';&#13;
			}&#13;
		}&#13;
	},&#13;
	&#13;
	Commented till here by Gulzar Manuja on 02/25/2020 */&#13;
	&#13;
	/*&#13;
	 * This function will validate if the user have enough remaining vacation time balance to apply&#13;
	 * Input:&#13;
	 *      @weekStart: Week Start Date&#13;
	 *      @nwtName: Name of the Non-Work Time&#13;
	 *      @remainingLTArray: Remaining Leave Time Array [{sysID: 'xyz', count: 2}, {sysID: 'abc', count: 3}]&#13;
	 *                         Sys IDs of Remaining Type of Leave Balance for Mon to Fri.&#13;
	 *                         For most of the timesheets, remainingLTArray will have only one element&#13;
	 *                         For the border case timesheet like end of year, it's possible to have 2 days of timesheet in current year&#13;
	 *                         and 3 days in next year. In such cases, first element will have sysID of first Leave Balance Record with count of days&#13;
	 *                         It covers (e.g. 2 if Mon, Tue) and next element will have sysID for next Leave Balance Record&#13;
	 *      @appliedHrs: Array of total hours applied for the each of the above leave balance&#13;
	 *      @hoursForEachWeekDay: This is an array of hours for each day e.g.: [4, 6, 2, 0, 8]&#13;
	 *      &#13;
	 * Return:&#13;
	 *     Returns nothing if vacation available&#13;
	 *     Returns error if works vacation not available&#13;
	 */&#13;
	&#13;
	/* Commented by Gulzar Manuja on 02/25/2020&#13;
	&#13;
	isVacationAvailable: function(weekStart, nwtName, remainingLTArray, appliedHrs, hoursForEachWeekDay) {&#13;
		"use strict";&#13;
		&#13;
		var snField = this.labelToSnName(nwtName);&#13;
		var weekDays = ['mon', 'tue', 'wed', 'thu', 'fri'];&#13;
		var remainingHrs;&#13;
		var gdt, endDate, startDate, count=0;&#13;
		var grlt = new GlideRecord(this.TABLE_LEAVE_TIME);&#13;
		&#13;
		gs.debug('isVacationAvailable: weekStart: {0}, nwtName: {1}, appliedHrs: {2}, snField: {3}', [weekStart, nwtName, appliedHrs, snField]);&#13;
		for (var l in remainingLTArray) {&#13;
			gs.debug(l+'. remainingLTArray[l].sysID: '+remainingLTArray[l].sysID+', remainingLTArray[l].count: '+remainingLTArray[l].count);&#13;
		}&#13;
		&#13;
		Commented till here by Gulzar Manuja on 02/25/2020 */&#13;
	&#13;
	&#13;
		&#13;
		/* For each leave balance record, check if vacation is available */&#13;
	/* Commented by Gulzar Manuja on 02/25/2020 &#13;
		for (var r in remainingLTArray) {&#13;
			var expiresOn;&#13;
			remainingHrs = 0;&#13;
			&#13;
			//Get the Remaining Leave Balance Record&#13;
			grlt.get(remainingLTArray[r].sysID);&#13;
			&#13;
			//Get the Remaining Hours for the leave type (vacation, sl, ....)&#13;
			remainingHrs = grlt.getValue(snField);&#13;
			gs.debug('grlt.type: '+grlt.type+', grlt.getValue(snField): '+grlt.getValue(snField)+', Remaining Hrs: '+remainingHrs);&#13;
			&#13;
			//If remaining hours are less than applied hours, return error&#13;
			if (parseFloat(remainingHrs) &lt; parseFloat(appliedHrs[r]))&#13;
				return "You don't have enought hours left to apply for leave: "+nwtName+". Remaining: "+remainingHrs+", Applied: "+appliedHrs[r];&#13;
			&#13;
			if (nwtName == 'Carry Over Vacation')&#13;
				expiresOn = grlt.co_vac_expires_on;&#13;
			else if (nwtName == 'Carry Over DH')&#13;
				expiresOn = grlt.co_dh_expires_on;&#13;
			&#13;
			gs.debug('For '+nwtName+', expiresOn: '+expiresOn);&#13;
			&#13;
			// For the Carry Over (Vacation or DH), check if it's expired&#13;
			if (expiresOn) {&#13;
			Commented till here by Gulzar Manuja on 02/25/2020 */&#13;
				/*&#13;
				 * Run from Last day till first day&#13;
				 * If remainingLTArray[0].count is 2 then run it from Tue(1) to Mon(0)&#13;
				 * If remainingLTArray[1].count is 3 then run it from Fri(2+3-1=4) to Wed(2)&#13;
				 */&#13;
	&#13;
	/* Commented by Gulzar Manuja on 02/25/2020&#13;
				for(var c=remainingLTArray[r].count+count-1; c&gt;=count; c--) {&#13;
					if (hoursForEachWeekDay[c] &amp;&amp; hoursForEachWeekDay[c]&gt;0) {&#13;
						endDate = new GlideDateTime(expiresOn.toString()).getDate();&#13;
						&#13;
						gdt = new GlideDateTime(weekStart.toString());&#13;
						gdt.addDaysLocalTime(c);&#13;
						startDate = gdt.getDate();&#13;
						&#13;
						gs.debug('c: {0}, startDate: {1}, endDate: {2}, subtract: {3}', [c, startDate, endDate,GlideDate.subtract(startDate, endDate).getDisplayValue()]);&#13;
						// this subtract function returns null if end (endDate) is less than begin (startDate)&#13;
						// So, this if loop will run till weekStart is not greater than or equal to effectiveFromDate&#13;
						if (!GlideDate.subtract(startDate, endDate).getDisplayValue())&#13;
							return nwtName+" has been expired on "+expiresOn+". You can't use it anymore.";&#13;
						break;&#13;
					}&#13;
				}&#13;
			}&#13;
			count += remainingLTArray[r].count;&#13;
		}&#13;
	},&#13;
	&#13;
	Commented till here by Gulzar Manuja on 02/25/2020 */&#13;
	&#13;
	/*&#13;
	 * This funciton will delete current ADP Report and generate a new one for the exception period between start and end&#13;
	 * Input:&#13;
	 *      @start and @end: Date period for which ADP period need to be generated.&#13;
	 *      @batchID: batchID string in the payroll schedule record. It's used for ADP purpose.&#13;
	 */&#13;
	&#13;
	/* Commented by Gulzar Manuja on 02/25/2020&#13;
	&#13;
	generateADPReport: function(start, end, batchID) {&#13;
		"use strict";&#13;
		&#13;
		gs.debug('generateADPReport: Generating Report for Payroll with exception start: {0}, end: {1}, batchID: {2}', start, end, batchID);&#13;
		var ot, sh, nonworktime;&#13;
		&#13;
		// Delete all Existing Records from the ADP Report Table&#13;
		var ar = new GlideRecord(this.TABLE_ADP_REPORT);&#13;
		ar.deleteMultiple();&#13;
		&#13;
		Commented till here by Gulzar Manuja on 02/25/2020 */&#13;
		&#13;
		/* Get List of all Users&#13;
		 * Reason behind getting all the users is that there may be few users who has been terminated by the time Payroll goes to create ADP report&#13;
		 * Which is normally 15 days behind. So, there may be users who were active at that time and submitted timesheets and aren't active any more.&#13;
		 * Also, we get the list of all the users because we can't be sure if a user is Consultant now, what was user's status few weeks ago&#13;
		 * This can be deduced only by the Timesheet.employee_type field&#13;
		 * which is set at the time Employee creates the timesheet and doesn't change even if Employee's type changes in future.&#13;
		 */&#13;
	&#13;
	/* Commented by Gulzar Manuja on 02/25/2020&#13;
		&#13;
		var grup = new GlideRecord(this.TABLE_USER_PROFILE);&#13;
		grup.query();&#13;
		var grts;&#13;
		gs.debug('generateADPReport: Total User Profiles: {0}', grup.getRowCount());&#13;
		while (grup.next()) {&#13;
			//Get all the Approved timesheets for the users in the exception period (start - end)&#13;
			var timesheet = this.snUtils.getO(this.TABLE_TIMESHEET, ['week_start&gt;='+start, 'week_start&lt;'+end, 'employee='+grup.sys_id, 'employee_type=Employee', 'state=Payroll Approved'], ['ot', 'sh', 'mon', 'tue', 'wed', 'thu', 'fri', 'holidays']);&#13;
			gs.debug('generateADPReport: For period between {0} and {1}, total {2} Payroll Approved Timesheets (with timesheet.employee_type = Employee) found for Employee: {3}', start, end, timesheet.length, grup.name);&#13;
			if (timesheet.length&gt;0) {&#13;
				ar.initialize();&#13;
				ot = 0;&#13;
				sh = 0;&#13;
				&#13;
				// If there is only one timesheet for an employee, we can assume that it's because employee resigned&#13;
				// Which means that 1 week (40 hours) would be considered as a non work time for that employee.&#13;
				nonworktime = timesheet.length == 1 ? 40 : 0;&#13;
				&#13;
				// Retrieve Overtime and Straight Hours for the Employee&#13;
				for (var ts in timesheet) {&#13;
					gs.debug('generateADPReport: timesheet['+ts+']: '+timesheet[ts]);&#13;
					ot += timesheet[ts].ot ? parseFloat(timesheet[ts].ot) : 0;&#13;
					sh += timesheet[ts].sh ? parseFloat(timesheet[ts].sh) : 0;&#13;
					['mon', 'tue', 'wed', 'thu', 'fri'].forEach(function(wd) {&#13;
						if (!(timesheet[ts].holidays &amp;&amp; timesheet[ts].holidays.contains(wd)))&#13;
							nonworktime += timesheet[ts][wd] == 0? 8 : 0;&#13;
					});&#13;
				}&#13;
				&#13;
				//Get total of all non work times for all timesheets for the user in the exception period&#13;
				var amount, i, j = [1, 1, 1];&#13;
				var type, code;&#13;
				var nwtObjArr = this.snUtils.getO(this.TABLE_NON_WORK_TIME, ['timesheet.week_start&gt;='+start, 'timesheet.week_start&lt;'+end, 'timesheet.employee='+grup.sys_id, 'timesheet.state=Payroll Approved'], ['nwt.name', 'nwt.code', 'nwt.type', 'total']);&#13;
				for(var x=0; x&lt;nwtObjArr.length; x++) {&#13;
					type = nwtObjArr[x]['nwt.type'];&#13;
					code = nwtObjArr[x]['nwt.code'];&#13;
					amount = nwtObjArr[x].total? nwtObjArr[x].total: 0;&#13;
					&#13;
					if (nwtObjArr[x]['nwt.name'] != 'Lunch Break')&#13;
						nonworktime += parseFloat(amount);&#13;
					i = parseFloat(type)-3;&#13;
					&#13;
					var found = false;&#13;
					for (var k=1; k&lt;j[i]; k++) {&#13;
						if (ar.getValue('hours_'+type+'_code_'+k) == code) {&#13;
							found = true;&#13;
							amount = parseFloat(amount) + parseFloat(ar.getValue('hours_'+type+'_amount_'+k));&#13;
							ar.setValue('hours_'+type+'_amount_'+k, amount);&#13;
							break;&#13;
						}&#13;
					}&#13;
					if (!found) {&#13;
						ar.setValue('hours_'+type+'_code_'+j[i], code);&#13;
						ar.setValue('hours_'+type+'_amount_'+j[i], amount);&#13;
						j[i]++;&#13;
					}&#13;
				}&#13;
				ar.co_code     = this.CO_CODE;&#13;
				ar.file_number = grup.file;&#13;
				ar.batch_id    = batchID;&#13;
				ar.o_t_hours   = ot;&#13;
				var regHours   = parseFloat(this.REG_HOURS) + parseFloat(sh) - parseFloat(nonworktime);&#13;
				regHours       = parseFloat(regHours).toFixed(2);&#13;
				ar.reg_hours   = regHours &gt; parseFloat(6.67) ? regHours : 0;&#13;
				gs.debug('generateADPReport: for user: '+grup.name+', OT: '+ot+', SH: '+sh+', NonWorkTime: '+nonworktime+', reg_hours: '+ar.reg_hours+', regHours: '+regHours);&#13;
				var sysID = ar.insert();&#13;
				if (!sysID)&#13;
					gs.error('generateADPReport: Failed to insert Record in ADP Report for user: {0}', grup.name);&#13;
				else&#13;
					gs.debug('generateADPReport: Inserted Record in ADP Report for user: {0}', grup.name);&#13;
				&#13;
			}&#13;
		}&#13;
	},&#13;
		&#13;
		Commented till here by Gulzar Manuja on 02/25/2020 */&#13;
	&#13;
	/*&#13;
 	* Parameters&#13;
 	* timesheet (GlideRecord): for which we need to verify the minimum 7 hours per week-day rule&#13;
 	*&#13;
 	* Returns&#13;
 	* error, If any weekday with less than 7 hours found for which 7 hours rule applies&#13;
	* nothing otherwise&#13;
 	*/&#13;
	/* 29-Feb-2020 - Lavlesh Garg, Do Not Delete this&#13;
	validateMin7HrDayRule: function (timesheet) {&#13;
		var daysToWork7Hours = timesheet.working_days ? timesheet.working_days.split(',') : '';&#13;
		if (!daysToWork7Hours || daysToWork7Hours == undefined || daysToWork7Hours === '')&#13;
			daysToWork7Hours = this.getWorkingDays(timesheet.week_start, timesheet.resource.start_date, timesheet.resource.end_date, timesheet.resource_type || timesheet.resource.user_type, timesheet.resource.working_days_for_pte);&#13;
		for (var w in daysToWork7Hours) {&#13;
			if (parseFloat(timesheet.getValue(daysToWork7Hours[w])) &lt; 7) {&#13;
				return 'Minimum 7 hours for '+daysToWork7Hours[w]+', you filled '+timesheet.getValue(daysToWork7Hours[w]);&#13;
			}&#13;
		}&#13;
	},*/&#13;
	&#13;
	/*&#13;
 	* Parameters:&#13;
 	* wStart: Start Date of the week (Monday) for the timesheet&#13;
 	* eStart: Start Date of employment&#13;
 	* eEnd: End date of employment&#13;
	* resourceType: 'PTE', 'FTE' or 'Contractor'&#13;
 	* pteWorkingDays: for a Part Time Employee (PTE), comma separated list of working days (tue,wed etc...)&#13;
 	*&#13;
	* Returns:&#13;
 	* Comma Separated list of working days&#13;
	* This would have 2 considerations:&#13;
	* 1) Resource's Hire and Termination Date, if they are mid week, then days before hire date or&#13;
	*    days after termination date won't we working days&#13;
	* 2) If Employee is Part Time, working days would be the subset of&#13;
	*    the above and the pre decided working days recorded in resource proifle &#13;
	*&#13;
 	*/&#13;
	getWorkingDays: function(wStart, eStart, eEnd, resourceType, pteWorkingDays) {&#13;
		"use strict";&#13;
		var weekStart           = wStart ? new GlideDateTime(wStart) : '';&#13;
		var employmentStart     = eStart ? new GlideDateTime(eStart) : '';&#13;
		var employmentEnd       = eEnd   ? new GlideDateTime(eEnd) : '';&#13;
		var days = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];&#13;
		if (!weekStart)&#13;
			return;&#13;
		var diffWeekStartEmploymentStart = employmentStart ? GlideDateTime.subtract(weekStart, employmentStart).getDayPart() : employmentStart;&#13;
		var diffWeekStartEmploymentEnd   = employmentEnd  ? GlideDateTime.subtract(weekStart, employmentEnd).getDayPart() : employmentEnd;&#13;
&#13;
		// if diffWeekStartEmploymentStart is upto 6 days after the week start of timesheet&#13;
		// than remove all the days from the start of the week till the (excluding) employement start date&#13;
		// as resource wouldn't work on those days&#13;
		// If employee start date is after 6 days from the week start of the timesheet, there won't be any working days&#13;
		// as employee haven't yet join so return empty array&#13;
		if (diffWeekStartEmploymentStart) {&#13;
			if (diffWeekStartEmploymentStart &gt; 6)&#13;
				return [];&#13;
			while (diffWeekStartEmploymentStart-- &gt; 0)				&#13;
				days.shift();&#13;
		}&#13;
		// similarly diffWeekStartEmploymentEnd is upto 7 days after the week start of timesheet&#13;
		// than remove all the days from the end of the week till the (excluding) employement end date&#13;
		// as resource wouldn't work on those days&#13;
		// If employee last date is before the week start of the timesheet, there won't be any working days&#13;
		// as employee has already left, so return empty array&#13;
		if (diffWeekStartEmploymentEnd) {&#13;
			if (diffWeekStartEmploymentEnd &lt; 0)&#13;
				return [];&#13;
			while (diffWeekStartEmploymentEnd++ &lt; 6)&#13;
				days.pop();&#13;
		}&#13;
		// A Part Time Employee only work on certain days which are recorded in the 'working_days_for_pte' field&#13;
		// All other works normally on week days&#13;
		// So, we record such days in employeeGeneralWorkingDays&#13;
		var employeeGeneralWorkingDays = ['mon', 'tue', 'wed', 'thu', 'fri'];&#13;
		if (resourceType == 'PTE' &amp;&amp; pteWorkingDays &amp;&amp; pteWorkingDays != undefined &amp;&amp; pteWorkingDays !== '')&#13;
			employeeGeneralWorkingDays = pteWorkingDays.toString().split(',');&#13;
		// and we take common of 'days' and 'employeeGeneralWorkingDays' are the qualfied days on which employee must work 7 hours&#13;
		var qualifiedDays = [];&#13;
		for (var e in employeeGeneralWorkingDays) {&#13;
			if (days.indexOf(employeeGeneralWorkingDays[e]) != -1)&#13;
				qualifiedDays.push(employeeGeneralWorkingDays[e]);&#13;
		}&#13;
		return qualifiedDays;&#13;
	},&#13;
	&#13;
	labelToSnName: function labelToSnName(l) {&#13;
		"use strict";&#13;
		&#13;
		return l.toLowerCase().split(/\(|\s+|\)|\/|\-/).filter(function (x) {return x;}).join('_');&#13;
	},&#13;
	&#13;
	getStartOfCurrentWeek: function(userId) {&#13;
		"use strict";&#13;
		&#13;
		var today = new GlideDate();&#13;
		if (gs.nil(userId))&#13;
			userId = gs.getUserID();&#13;
		return this.getStartOfWeekByDate(today, userId);&#13;
	},&#13;
	&#13;
	getStartOfWeekByDate: function(aDate, userId) {&#13;
		"use strict";&#13;
		&#13;
		//var timeSheetPolicy = TimeSheetPolicy.getFromUserId(userId);&#13;
		var firstDayOfWeek = 1; // 1 = Monday //timeSheetPolicy.weekStartsOn();&#13;
		&#13;
		var gd = new GlideDate();&#13;
		gd.setValue(aDate);&#13;
		var currentDay = gd.getDayOfWeekUTC();&#13;
		&#13;
		var daysInWeek = 7;&#13;
		var daysToMoveBehind = (firstDayOfWeek - currentDay - daysInWeek) % daysInWeek;&#13;
		gd.addDaysUTC(daysToMoveBehind);&#13;
		&#13;
		return gd;&#13;
	},&#13;
	&#13;
	getWeekStartsOnDateTimeForUser: function(weekStartsOnDate, userId) {&#13;
		"use strict";&#13;
		&#13;
		var gr = new GlideRecord('sys_user');&#13;
		gr.get(userId);&#13;
		var timeZoneId = gr.getValue('time_zone');&#13;
		var timeZone;&#13;
		if (global.JSUtil.nil(timeZoneId))&#13;
			timeZone = gs.getSession().getTimeZone();&#13;
		else&#13;
			timeZone = Packages.java.util.TimeZone.getTimeZone(timeZoneId);&#13;
		&#13;
		var weekStartsOnDateTimeForUser = new GlideDateTime();&#13;
		weekStartsOnDateTimeForUser.setTZ(timeZone);&#13;
		weekStartsOnDateTimeForUser.setDisplayValueInternal(weekStartsOnDate + ' 00:00:00');&#13;
		return weekStartsOnDateTimeForUser;&#13;
	},&#13;
	&#13;
	/*&#13;
 	* Parameters&#13;
 	* timesheet: for which we need to verify the minimum 0 hour per week-day for Consultants&#13;
 	*&#13;
 	* Returns&#13;
 	* false, If any weekday found with 0 hour&#13;
 	* true, otherwise&#13;
 	*/&#13;
	find0HrWeekDayRule: function (timesheet) {&#13;
		"use strict";&#13;
		&#13;
		var weekDays = this.getWeekDays(timesheet.week_start, timesheet.employee.start_date, timesheet.employee.end_date);&#13;
		gs.debug('current.timesheet: {0}, wStart: {1}, eStart: {2}, eEnd: {3}', timesheet.timesheet, timesheet.week_start, timesheet.employee.start_date, timesheet.employee.end_date);&#13;
		for (var w in weekDays) {&#13;
			if (parseFloat(timesheet.getValue(weekDays[w])) == 0) {&#13;
				return true;&#13;
			}&#13;
		}&#13;
	},&#13;
	&#13;
	&#13;
	/* Commented by Gulzar Manuja on 02/25/2020&#13;
	&#13;
	getLunchBreakToUpdate: function (timesheet) {&#13;
		&#13;
		gs.debug('getLunchBreakToUpdate: timesheet: '+timesheet.timesheet);&#13;
		var lunchHours = [];&#13;
		var weekDaysToBypass = timesheet.bypass_7_hr_pwd_rule_for_days.toString().split(',');&#13;
		var totalNWT = this.getTotalHrsForEachDayNWT(timesheet);&#13;
		gs.debug('getLunchBreakToUpdate timesheet: '+timesheet.timesheet+', totalNWT: '+totalNWT+', weekDaysToBypass: '+weekDaysToBypass);&#13;
		if (totalNWT &amp;&amp; totalNWT.length&gt;=5) {&#13;
			for (var t=0; t&lt;5; t++) {&#13;
				if (totalNWT[t][1] &gt;= 4 || (weekDaysToBypass &amp;&amp; this.au.contains(weekDaysToBypass, totalNWT[t][0]))) {&#13;
					lunchHours.push([totalNWT[t][0], 0]);&#13;
				} else {&#13;
					lunchHours.push([totalNWT[t][0], 1]);&#13;
				}&#13;
			}&#13;
			gs.debug('getLunchBreakToUpdate: timesheet: '+timesheet.timesheet+', lunchHours: '+lunchHours);&#13;
			return lunchHours;&#13;
		}&#13;
	},&#13;
	&#13;
	Commented till here by Gulzar Manuja on 02/25/2020 */&#13;
	&#13;
	&#13;
	/*&#13;
 	* This function will take a user profile as an argument&#13;
 	* and will update all the bill rates for that user profile&#13;
 	* with total hours worked on each bill rate&#13;
 	*/&#13;
	updateBillRateForUser: function(userProfile) {&#13;
		var billRate = new GlideRecord(this.TABLE_BILL_RATE);&#13;
		billRate.addQuery('user', userProfile);&#13;
		billRate.orderBy('effective_from_date');&#13;
		billRate.query();&#13;
		while (billRate.next()) {&#13;
			hours = this.getHoursForBillRate(billRate);&#13;
			gs.debug('Updating Bill Rate for user: {0} with Effective From Date: {1}, Effective Till Date: {2}, Hours: {3}', billRate.user.name, billRate.effective_from_date, billRate.effective_till_date, hours);&#13;
			billRate.total_hours_on_this_rate = hours;&#13;
			billRate.setWorkflow(false);&#13;
			billRate.update();&#13;
		}&#13;
	},&#13;
	&#13;
	/*&#13;
 	* This function will calculate the total hours worked by an employee on the given Bill Rate.&#13;
 	* Input: Bill Rate Record&#13;
 	* Output: Total number of hours worked by the employee on the given Bill Rate&#13;
 	*/&#13;
	getHoursForBillRate: function(billRate) {&#13;
		var effectiveFromDate, effectiveTillDate, hours=0;&#13;
		var weekDays = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];&#13;
		var start, end;&#13;
		var weekStart, weekEnd;&#13;
		&#13;
		effectiveFromDate = new GlideDate();&#13;
		effectiveFromDate.setValue(billRate.effective_from_date.toString());&#13;
		&#13;
		//If effective till date is present (current active bill rate may not have effective till date)&#13;
		if (billRate.effective_till_date) {&#13;
			effectiveTillDate = new GlideDate();&#13;
			effectiveTillDate.setValue(billRate.effective_till_date.toString());&#13;
		}&#13;
		&#13;
		//Get all the timesheets for the employee which falls between the effective from date and till date&#13;
		var grts = new GlideRecord(this.TABLE_TIMESHEET);&#13;
		grts.addQuery('resource='+billRate.user);&#13;
		grts.addQuery('week_end&gt;='+effectiveFromDate.toString());&#13;
		&#13;
		//If effective till date is present, add it to the query&#13;
		if (effectiveTillDate) {&#13;
			grts.addQuery('week_start&lt;='+effectiveTillDate.toString());&#13;
		}&#13;
		grts.query();&#13;
		&#13;
		//For each timesheet, calculate eligible hours and add them&#13;
		while (grts.next()) {&#13;
			&#13;
			/*&#13;
 			* We are going to check if effective start / till date falls between the week&#13;
 			* if effective start date falls on Tuesday, start will be 1 [0 signifies Monday]&#13;
 			* if effective till date falls on Friday, end will be 4 [6 signifies Sunday]&#13;
 			*/&#13;
			start = 0;&#13;
			end = 6;&#13;
			&#13;
			weekStart = new GlideDateTime(grts.week_start.toString());&#13;
			weekStart.addDaysUTC(-1);&#13;
			while (start&lt;=6) {&#13;
				weekStart.addDaysUTC(1);&#13;
				// this subtract function returns null if end (weekStart) is less than begin (effectiveFromDate)&#13;
				// So, this if loop will run till weekStart is not greater than or equal to effectiveFromDate&#13;
				// If it's already greater than or equal to effectiveFromDate, it will break and start will remain as 0 meaning Monday&#13;
				if (GlideDate.subtract(effectiveFromDate, weekStart.getDate()).getDisplayValue())&#13;
					break;&#13;
				start++;&#13;
			}&#13;
			&#13;
			if (effectiveTillDate) {&#13;
				weekEnd = new GlideDateTime(grts.week_end.toString());&#13;
				weekEnd.addDaysUTC(1);&#13;
				while (end&gt;=0) {&#13;
					weekEnd.addDaysUTC(-1);&#13;
					if (GlideDate.subtract(weekEnd.getDate(), effectiveTillDate).getDisplayValue())&#13;
						break;&#13;
					end--;&#13;
				}&#13;
			}&#13;
			&#13;
			for (var i=start; i&lt;=end; i++) {&#13;
				hours += parseFloat(grts.getValue(weekDays[i]));&#13;
			}&#13;
		}&#13;
		return hours;&#13;
	},&#13;
	&#13;
	/*&#13;
 	* This function will check if user (user sys_id) has the exactly role (name of the role) or not&#13;
 	*/&#13;
	hasRoleExactly : function(user, role) {&#13;
		var gr = new GlideRecord('sys_user_has_role');&#13;
		gr.addQuery('user', user);&#13;
		gr.addQuery('role.name', role);&#13;
		gr.query();&#13;
		if (gr.getRowCount() &gt; 0)&#13;
			return true;&#13;
		return false;&#13;
	},&#13;
	&#13;
	getLastDateOfMonth: function(month, year) {&#13;
		var gdt = new GlideDateTime();&#13;
		gdt.setMonthUTC(month);&#13;
		gdt.setYearUTC(year);&#13;
		var days = gdt.getDaysInMonthUTC();&#13;
		gdt.setDayOfMonthUTC(days);&#13;
		return gdt.getDate();&#13;
	},&#13;
	&#13;
	&#13;
	/* Commented by Gulzar Manuja on 02/25/2020&#13;
	&#13;
	createLeaveTime: function(type, employee, validFrom, leaveBalanceArray, coVacExpiresOn) {&#13;
		gs.debug('in the createLeaveTime function for type: '+type+', employee: '+employee+', validFrom: '+validFrom+', leaveBalanceArray: '+leaveBalanceArray+', coVacExpiresOn: '+coVacExpiresOn);&#13;
		if (!validFrom)&#13;
			return 'Failed to create Leave Time record for employee: '+employee+', type: '+type+' because of empty valid from date';&#13;
		&#13;
		var gdt = new GlideDateTime();&#13;
		gdt.setDisplayValue(validFrom.toString());&#13;
		gdt.addYearsLocalTime(1);&#13;
		gdt.addDaysLocalTime(-1);&#13;
		var validTill = gdt.getDate();&#13;
		&#13;
		var isUnique = this.isLeaveTimeUnique(type, employee, validFrom, validTill);&#13;
		if (!isUnique)&#13;
			return 'Failed to create Leave Time record for employee: '+employee+', type: '+type+' because of validity range from '+validFrom+', till '+validTill+', clashes with another leave time record';&#13;
		&#13;
		if (isUnique) {&#13;
			var grlt = new GlideRecord('x_nykl3_tenroxnbsa_leave_time');&#13;
			grlt.initialize();&#13;
			&#13;
			grlt.type = type;&#13;
			grlt.employee = employee;&#13;
			grlt.valid_from = validFrom;&#13;
			grlt.valid_till = validTill;&#13;
			&#13;
			if (coVacExpiresOn)&#13;
				grlt.co_vac_expires_on = coVacExpiresOn;&#13;
			&#13;
			if (leaveBalanceArray &amp;&amp; leaveBalanceArray.length&gt;0) {&#13;
				for (var lb in leaveBalanceArray) {&#13;
					grlt.setValue(leaveBalanceArray[lb][0], leaveBalanceArray[lb][1]);&#13;
				}&#13;
			}&#13;
			var sysID = grlt.insert();&#13;
			if (!sysID) return 'Failed to insert Leave Time record for employee: '+employee+', type: '+type+', valid from: '+validFrom;&#13;
			}&#13;
	},&#13;
	&#13;
	isLeaveTimeUnique: function(type, employee, validFrom, validTill, excludeSysID) {&#13;
		&#13;
		gs.debug('in isLeaveTimeUnique function for type: '+type+', employee: '+employee+', validFrom: '+validFrom+', validTill: '+validTill);&#13;
		&#13;
		var grlt = new GlideRecord('x_nykl3_tenroxnbsa_leave_time');&#13;
		var queryString = "type="+type;&#13;
		queryString += "^employee="+employee;&#13;
		queryString += "^sys_id!="+excludeSysID;&#13;
		queryString += "^valid_from&lt;="+validFrom;&#13;
		queryString += "^valid_till&gt;="+validFrom;&#13;
		&#13;
		queryString += "^NQtype="+type;&#13;
		queryString += "^employee="+employee;&#13;
		queryString += "^sys_id!="+excludeSysID;&#13;
		queryString += "^valid_from&lt;="+validTill;&#13;
		queryString += "^valid_till&gt;="+validTill;&#13;
		&#13;
		queryString += "^NQtype="+type;&#13;
		queryString += "^employee="+employee;&#13;
		queryString += "^sys_id!="+excludeSysID;&#13;
		queryString += "^valid_from&gt;="+validFrom;&#13;
		queryString += "^valid_till&lt;="+validTill;&#13;
		&#13;
		gs.debug('queryString: '+queryString);&#13;
		grlt.addEncodedQuery(queryString);&#13;
		grlt.query();&#13;
		&#13;
		if (grlt.getRowCount() == 0)&#13;
			return true;&#13;
	},&#13;
	&#13;
	getLeaveTimeArray: function(employee, type, weekStart) {&#13;
		var gdt = new GlideDateTime(weekStart);&#13;
		var ltArray = [{}];&#13;
		var sysID, j=0;&#13;
		for (var i=0; i&lt;5; i++) {&#13;
			sysID = this.getLeaveTime(employee, type, gdt.getDate());&#13;
			if (!ltArray[j].sysID) {&#13;
				ltArray[j].sysID = sysID;&#13;
				ltArray[j].count = 0;&#13;
			}&#13;
			if (ltArray[j].sysID == sysID) {&#13;
				ltArray[j].count++;&#13;
			} else {&#13;
				ltArray[++j] = {};&#13;
				ltArray[j].sysID = sysID;&#13;
				ltArray[j].count = 1;&#13;
			}&#13;
			gdt.addDaysLocalTime(1);&#13;
		}&#13;
		return ltArray;&#13;
	},&#13;
	&#13;
	getLeaveTime: function(employee, type, date) {&#13;
		var lt = new GlideRecord(this.TABLE_LEAVE_TIME);&#13;
		var query = 'employee='+employee;&#13;
		query += '^type='+type;&#13;
		query += '^valid_from&lt;='+date;&#13;
		query += '^valid_till&gt;='+date;&#13;
		lt.addEncodedQuery(query);&#13;
		lt.query();&#13;
		if (lt.next())&#13;
			return lt.sys_id;&#13;
	},&#13;
	&#13;
	Commented till here by Gulzar Manuja on 02/25/2020 */&#13;
		&#13;
	// Returns True only if user is nbse_admin or timesheet_approver&#13;
	isAdminApproverUIActionAvailable: function(userSysID, timesheetApprover) {&#13;
		if (this.hasRoleExactly(userSysID, 'x_nyk_nbse_time_ca.nbse_admin'))&#13;
			return true;&#13;
		&#13;
		if (timesheetApprover &amp;&amp; timesheetApprover == userSysID)&#13;
				return true;&#13;
		&#13;
		return false;&#13;
	},&#13;
&#13;
    type: 'NBSETimeCardUtil'&#13;
};</script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>MANUJAG</sys_created_by>
        <sys_created_on>2020-02-07 12:53:47</sys_created_on>
        <sys_customer_update>false</sys_customer_update>
        <sys_id>56057c021bf64010f59b8734ec4bcb5f</sys_id>
        <sys_mod_count>49</sys_mod_count>
        <sys_name>NBSETimeCardUtil</sys_name>
        <sys_package display_value="NBSE Time Card" source="x_nyk_nbse_time_ca">00e16545dbf604901a9df77c2996198a</sys_package>
        <sys_policy>read</sys_policy>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="NBSE Time Card">00e16545dbf604901a9df77c2996198a</sys_scope>
        <sys_update_name>sys_script_include_56057c021bf64010f59b8734ec4bcb5f</sys_update_name>
        <sys_updated_by>GARGL</sys_updated_by>
        <sys_updated_on>2020-03-02 17:37:04</sys_updated_on>
    </sys_script_include>
</record_update>
